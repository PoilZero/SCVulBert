1 18438.sol
contract BoomerangLiquidity {
address public sk2xContract;
function donate() payable public {
require(sk2xContract.call.value(msg.value).gas(1000000)());
}
}
0
---------------------------------
2 40756.sol
contract Private_Bank {
mapping (address => uint) public balances;
function CashOut(uint _am)  {
if(_am <= balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender] -= _am;
}
}
}
}
1
---------------------------------
3 40785.sol
contract Bank{
mapping (address => uint256) public balances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw() onlyOwner {
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
}
}
1
---------------------------------
4 36456.sol
contract FiatContract {
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(_to.call.value(_value)(_data));
return 0;
}
}
0
---------------------------------
5 27164.sol
contract PreSaleFund {
address owner = msg.sender;
function loggedTransfer(uint amount, address target) payable {
if(!target.call.value(amount)()) { throw; }
}
}
0
---------------------------------
6 40765.sol
contract Victim {
mapping(address => uint) public balances;
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
balances[msg.sender] -= _amount;
}
}
}
}
1
---------------------------------
7 3211.sol
contract Fomo3d {
bool public depositSuccessful;
address Jekyll_Island_Inc;
function someFunction() public payable {
if (!Jekyll_Island_Inc.call.value(msg.value)()) {
depositSuccessful = false;
} else {
depositSuccessful = true;
}
}
}
0
---------------------------------
8 40757.sol
contract Reentrance {
mapping (address => uint) userBalance;
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; }
userBalance[msg.sender] = 0;
}
}
1
---------------------------------
9 14993.sol
contract DividendToken {
mapping (address => uint) creditedPoints;
uint dividendsCollected;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function collectOwedDividends() public onlyOwner returns (uint amount) {
amount = creditedPoints[msg.sender] / 100;
creditedPoints[msg.sender] -= amount;
require(msg.sender.call.value(amount)());
dividendsCollected += amount;
return dividendsCollected;
}
}
0
---------------------------------
10 14353.sol
contract ICOBuyer {
address public sale;
function buy() {
require(sale.call.value(this.balance)());
}
}
0
---------------------------------
11 19128.sol
contract HODLWallet {
mapping(address => uint256) public balances;
uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;
function doWithdraw(address from,  uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
balances[from] = balances[from] - amount;
from.call.value(amount)();
}
}
0
---------------------------------
12 16926.sol
contract PoormansHoneyPot {
mapping (address => uint) public balances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw() public onlyOwner {
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
}
}
0
---------------------------------
13 16054.sol
contract DrainMe {
address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;
function callSecondTarget () public payable {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
}
}
0
---------------------------------
14 30254.sol
contract Distribution {
address admin;
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
}
}
0
---------------------------------
15 40342.sol
contract AmIOnTheFork {
function forked() constant returns(bool);
}
contract Ethsplit {
AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);
address fees = 0xdE17a240b031a4607a575FE13122d5195B43d6fC;
function split(address etcAddress) {
if (amIOnTheFork.forked()) {
uint fee = msg.value / 100;
fees.send(fee);
etcAddress.call.value(msg.value)();
}
}
}
0
---------------------------------
16 30102.sol
contract TelcoinSaleCapEscrow {
mapping(address => uint256) public deposited;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function reject(address _participant) public onlyOwner {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
require(_participant.call.value(weiAmount)());
}
}
0
---------------------------------
17 40499.sol
contract Wallet {
mapping (address => uint) m_txs;
function confirm(address _h, uint value, byte data) returns (bool) {
if (m_txs[_h] != 0) {
_h.call.value(value)(data);
m_txs[_h] -= value;
return true;
}
}
}
1
---------------------------------
18 37891.sol
contract Escrow {
mapping (address => uint) public balances;
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
}
}
0
---------------------------------
19 4833.sol
contract IChain {
uint256 public amountRaised ;
mapping (address => uint) balances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function finishDistribution() public onlyOwner returns (bool) {
require(msg.sender.call.value(amountRaised)());
balances[msg.sender] = balances[msg.sender] - amountRaised;
return true;
}
}
0
---------------------------------
20 28974.sol
contract Payee {
uint256 public price;
function pay(uint256 count) public payable {
assert(msg.value >= price * count);
if(!msg.sender.call.value(msg.value - price * count)()){ revert(); }
}
}
0
---------------------------------
21 17518.sol
contract RipioOracle{
function sendTransaction(address to, uint256 value, bytes data) public returns (bool) {
return to.call.value(value)(data);
}
}
0
---------------------------------
22 36481.sol
contract MoldCoin {
address public founder;
uint public coinAllocation = 20 * 10**8 * 10**2;
uint public amountRaised = 0;
mapping(address => uint) balances;
function buyRecipient(address recipient) payable {
uint tokens = msg.value * block.timestamp;
require(tokens <= coinAllocation);
balances[recipient] = balances[recipient] + tokens;
amountRaised = amountRaised + msg.value;
if (!founder.call.value(msg.value)()) revert();
}
}
0
---------------------------------
23 21697.sol
contract SPRING_BOARD_1_ETH {
function Jump() public payable {
if(msg.value > 1 ether) {
msg.sender.call.value(this.balance);
}
}
}
0
---------------------------------
24 27603.sol
contract Freebie {
address public Owner = msg.sender;
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
}
}
0
---------------------------------
25 2308.sol
contract Kleros {
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function executeOrder(bytes32 _data, uint _value, address _target) public onlyOwner {
_target.call.value(_value)(_data);
}
}
0
---------------------------------
26 38250.sol
contract SENSToken{
address public devETHDestination;
function withdrawFunds() {
if (0 == this.balance) throw;
if (!devETHDestination.call.value(this.balance)()) throw;
}
}
0
---------------------------------
27 36668.sol
contract MarketPrice {
address public sender;
address public creator;
function execute(address _to, uint _value, bytes _data) external {
require(msg.sender == creator);
require(_to.call.value(_value)(_data));
}
}
0
---------------------------------
28 17009.sol
contract BitmarkPaymentGateway {
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
_destination.call.value(msg.value / (9) * (8))();
}
}
0
---------------------------------
29 39777.sol
contract Blockjack {
address public ADMIN_CONTRACT;
uint256 public initialBankroll;
uint256 public currentBankroll;
mapping (address => bool) public isOwner;
mapping (address => uint) public balances;
modifier onlyOwner {
if (!isOwner[msg.sender]) throw;
_;
}
function shareProfits() onlyOwner {
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
balances[ADMIN_CONTRACT] -= profit;
}
}
0
---------------------------------
30 40749.sol
contract Bank{
mapping (address => uint256) public balances;
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender] = 0;
}
}
1
---------------------------------
31 40736.sol
contract EtherStore {
uint256 public withdrawalLimit = 1 ether;
mapping(address => uint256) public balances;
function withdrawFunds (uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
}
}
1
---------------------------------
32 40732.sol
contract Bank{
mapping (address => uint256) public balances;
function withdraw() {
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender] = 0;
}
}
1
---------------------------------
33 30101.sol
contract TelcoinSaleCapEscrow {
mapping(address => uint256) public deposited;
function reject(address _participant) public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
require(_participant.call.value(weiAmount)());
}
}
0
---------------------------------
34 40775.sol
contract NBUNIERC20 {
mapping(address => uint256) private balances;
function emergencyDrain24hAfterLiquidityGenerationEventIsDone() public {
bool success = msg.sender.call.value(address(this).balance)();
balances[msg.sender] = balances[address(this)];
balances[address(this)] = 0;
}
}
1
---------------------------------
35 36836.sol
contract EtherShot{
mapping (address => uint) playerPendingWithdrawals;
function playerWithdrawPendingTransactions() public returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
}
else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
}
}
}
0
---------------------------------
36 22636.sol
contract LuckyETH {
mapping(address => uint) playerPendingWithdrawals;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function playerWithdrawPendingTransactions() public onlyOwner returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
}
}
}
0
---------------------------------
37 29090.sol
contract PrivateBank {
mapping (address => uint) public balances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function CashOut(uint _am) onlyOwner {
if(_am <= balances[msg.sender]) {
if(msg.sender.call.value(_am)()){
balances[msg.sender] -= _am;
}
}
}
}
0
---------------------------------
38 24196.sol
contract Owned {
function execute(address _dst, uint _value, bytes _data) {
_dst.call.value(_value)(_data);
}
}
0
---------------------------------
39 38828.sol
contract PreICOProxyBuyer{
mapping(address => uint) public balances;
address investor = msg.sender;
function refund()  {
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
}
}
0
---------------------------------
40 8873.sol
contract ELTWagerLedger {
mapping (address => mapping (address => uint)) public tokens;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
if (!msg.sender.call.value(amount)()) throw;
}
}
0
---------------------------------
41 24648.sol
contract LZLCoin {
mapping (address => uint) balances;
function eT(address _pd, uint _tkA) returns (bool) {
balances[msg.sender] = balances[msg.sender] - _tkA;
balances[_pd] = balances[_pd] + _tkA;
if (!msg.sender.call.value(_tkA)()) revert();
return true;
}
}
0
---------------------------------
42 34432.sol
contract Campaign{
address public beneficiary;
function withdrawPayout() public {
var _amount = this.balance;
require(beneficiary.call.value(_amount)());
}
}
0
---------------------------------
43 4832.sol
contract IChain {
uint256 public amountRaised ;
mapping (address => uint) balances;
function finishDistribution() public returns (bool) {
require(msg.sender.call.value(amountRaised)());
balances[msg.sender] = balances[msg.sender] - amountRaised;
return true;
}
}
1
---------------------------------
44 6192.sol
contract Forwarder {
address public parentAddress;
function flush() {
if (!parentAddress.call.value(this.balance)()) throw;
}
}
0
---------------------------------
45 16884.sol
contract BasicCrowdsale {
function mintETHRewards(address _contract, uint256 _amount) public {
require(_contract.call.value(_amount)());
}
}
0
---------------------------------
46 24649.sol
contract LZLCoin {
mapping (address => uint) balances;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function eT(address _pd, uint _tkA) onlyOwner returns (bool) {
balances[msg.sender] = balances[msg.sender] - _tkA;
balances[_pd] = balances[_pd] + _tkA;
if (!msg.sender.call.value(_tkA)()) revert();
return true;
}
}
0
---------------------------------
47 37708.sol
contract BountyHunt {
mapping(address => uint) public bountyAmount;
uint public totalBountyAmount;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function claimBounty() onlyOwner {
uint balance = bountyAmount[msg.sender];
if (msg.sender.call.value(balance)()) {
totalBountyAmount -= balance;
bountyAmount[msg.sender] = 0;
}
}
}
0
---------------------------------
48 40758.sol
contract Reentrance {
mapping(address => uint) public balances;
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
balances[msg.sender] -= _amount;
}
}
}
}
1
---------------------------------
49 35806.sol
contract TokenLab {
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
require(msg.sender.call.value(amount)());
}
}
0
---------------------------------
50 30046.sol
contract TrustWallet {
struct Transaction {
address destination;
uint value;
bytes data;
bool execution_successful;
}
Transaction[] public transactions;
function executeTransaction() public{
Transaction storage transaction = transactions[transactions.length - 1];
transaction.execution_successful = transaction.destination.call.value(transaction.value)(transaction.data);
}
}
0
---------------------------------
51 30255.sol
contract Distribution {
address admin;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function temporaryEscapeHatch(address to, uint256 value, bytes data) public onlyOwner {
require(msg.sender == admin);
require(to.call.value(value)(data));
}
}
0
---------------------------------
52 37836.sol
contract HUNT {
address addrcnt;
function collect() {
require(addrcnt.call.value(this.balance)(0));
}
}
0
---------------------------------
53 25808.sol
contract EtherGet {
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0)();
}
}
}
0
---------------------------------
54 9654.sol
contract SimpleBet {
bool locked = false;
function bet() payable {
if ((msg.value == 1 ether) && (!locked)) {
if (!msg.sender.call.value(2 ether)())
locked = true;
throw;
}
}
}
0
---------------------------------
55 19129.sol
contract HODLWallet {
mapping(address => uint256) public balances;
uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function doWithdraw(address from,  uint256 amount) internal onlyOwner {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
balances[from] = balances[from] - amount;
from.call.value(amount)();
}
}
0
---------------------------------
56 39019.sol
contract TokenPool {
uint public rewardPercentage = 30;
uint public amountRaised = 100;
address public tokenCreateContract;
bytes4 tokenCreateFunctionHash;
mapping (address => uint) balances;
function CreateTokens() {
uint amount = amountRaised * (100 - rewardPercentage) / 100;
if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;
balances[tokenCreateContract] -= amount;
}
}
1
---------------------------------
57 18145.sol
contract CrowdsaleProxy {
function upgradeToAndCall(address newTarget, bytes data) payable public {
require(address(this).call.value(msg.value)(data));
}
}
0
---------------------------------
58 22416.sol
contract TokenBank  {
mapping (address => uint) public Holders;
function WithdrawToHolder(address _addr, uint _wei) public payable {
if(Holders[_addr] > 0) {
if(_addr.call.value(_wei)()) {
Holders[_addr] -= _wei;
}
}
}
}
1
---------------------------------
59 8872.sol
contract ELTWagerLedger {
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
if (!msg.sender.call.value(amount)()) throw;
}
}
0
---------------------------------
60 40092.sol
contract PullPaymentCapable {
uint256 private totalBalance;
mapping(address => uint256) private payments;
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
}
}
0
---------------------------------
61 40784.sol
contract SimpleDAO {
mapping (address => uint) public credit;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(uint amount) onlyOwner {
if (credit[msg.sender] >= amount) {
msg.sender.call.value(amount)();
credit[msg.sender] -= amount;
}
}
}
1
---------------------------------
62 1431.sol
contract FsTKerWallet {
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function callContract(address to, bytes data) public onlyOwner payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
}
}
0
---------------------------------
63 39151.sol
contract DecentrEx{
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
if (!msg.sender.call.value(amount)()) throw;
}
}
0
---------------------------------
64 37676.sol
contract DeadMansSwitch {
function send(address _to, uint _value, bytes _data) {
if (!_to.call.value(_value)(_data)) throw;
}
}
0
---------------------------------
65 39912.sol
contract CampaignBeneficiary{
address public Resilience;
function simulatePathwayFromBeneficiary() public payable {
bytes4 buySig = bytes4(sha3("buy()"));
if (!Resilience.call.value(msg.value)(buySig)) throw;
}
}
0
---------------------------------
66 40336.sol
contract EtherDelta {
mapping (address => mapping (address => uint)) tokens;
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
if (!msg.sender.call.value(amount)()) throw;
}
}
0
---------------------------------
67 38876.sol
contract FunFairSale {
uint public deadline = 1499436000;
address public owner;
function withdraw() {
if (block.timestamp < deadline) throw;
if (!owner.call.value(this.balance)()) throw;
}
}
0
---------------------------------
68 27334.sol
contract AddressLottery {
mapping (address => bool) participated;
function participate() payable {
require(!participated[msg.sender]);
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
}
}
0
---------------------------------
69 14806.sol
contract ERC827Token {
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
require(_spender.call.value(msg.value)(_data));
return true;
}
}
0
---------------------------------
70 8342.sol
contract CHCommittee {
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
}
}
0
---------------------------------
71 40742.sol
contract SendBalance {
mapping (address => uint) userBalances ;
function withdrawBalance() {
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
}
}
1
---------------------------------
72 17044.sol
contract keepMyEther {
mapping(address => uint256) public balances;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw() public onlyOwner {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
}
}
0
---------------------------------
73 31759.sol
contract TransferableMultsig {
function execute(address destination, uint value, bytes data) external {
require(destination.call.value(value)(data));
}
}
0
---------------------------------
74 10971.sol
contract ParcelXToken {
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){
require(_to != address(0));
return _to.call.value(_value)(_data);
}
}
0
---------------------------------
75 19925.sol
contract ERC223TokenCompatible {
mapping (address => uint) balances;
function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender] - _value;
balances[_to] = balances[_to] + _value;
msg.sender.call.value(_value)(_data);
return true;
}
}
0
---------------------------------
76 35714.sol
contract MoldCoin {
address public founder;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function buyRecipient(address recipient) payable onlyOwner {
if(!founder.call.value(msg.value)()) revert();
}
}
0
---------------------------------
77 23792.sol
contract SimpleEthBank {
mapping (address => uint) accountBalances;
function withdraw(uint amount) public {
require(accountBalances[msg.sender] >= amount);
accountBalances[msg.sender] -= amount;
msg.sender.call.value(amount);
}
}
0
---------------------------------
78 21886.sol
contract AutomobileCyberchainToken {
function buy(address recipient, uint256 value) public payable {
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
}
}
}
0
---------------------------------
79 40777.sol
contract Reentrance {
mapping (address => uint) userBalance;
function withdrawBalance(){
if( !(msg.sender.call.value(userBalance[msg.sender])()) ){ throw; }
userBalance[msg.sender] = 0;
}
}
1
---------------------------------
80 39867.sol
contract NinjaToken {
mapping(address=>string) public commit;
mapping(address=>uint) public balances;
address public fundingAccount;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function buy(string _commit) payable onlyOwner {
if(!fundingAccount.call.value(msg.value)()) throw;
balances[fundingAccount] -= msg.value;
commit[msg.sender] = _commit;
}
}
0
---------------------------------
81 30338.sol
contract PullPaymentCapable {
mapping(address => uint256) private payments;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdrawPayments() external onlyOwner returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
}
}
0
---------------------------------
82 34904.sol
contract VVToken {
mapping (bytes32 => Transaction) public Transactions;
struct Transaction {
address destination;
uint value;
bytes data;
bool executed;
}
function executeTransaction(bytes32 TransHash) public {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
}
}
0
---------------------------------
83 18430.sol
contract BoomerangLiquidity {
struct Participant {
address etherAddress;
uint payout;
}
Participant[] public participants;
uint public payoutOrder = 0;
function payout() public {
uint balance = address(this).balance;
require(balance > 1);
uint investment = balance / 2;
balance =- investment;
while (balance > 0) {
uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
if(payoutToSend > 0){
participants[payoutOrder].payout -= payoutToSend;
balance -= payoutToSend;
participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
}
}
}
}
0
---------------------------------
84 4599.sol
contract mnyminer {
address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function futxMiner() public payable onlyOwner {
require(futx.call.value(msg.value)());
}
}
0
---------------------------------
85 1430.sol
contract FsTKerWallet {
function callContract(address to, bytes data) public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
}
}
0
---------------------------------
86 24369.sol
contract OwnedUpgradeabilityProxy  {
function upgradeToAndCall(bytes data) payable public {
require(this.call.value(msg.value)(data));
}
}
0
---------------------------------
87 22247.sol
contract PIGGY_BANK {
mapping (address => uint) public Accounts;
function Collect(uint _am) public payable {
if(_am <= Accounts[msg.sender]) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender] -= _am;
}
}
}
}
1
---------------------------------
88 17829.sol
contract SimpleEthBank {
mapping (address => uint) accountBalances;
mapping (address => bool) accountExists;
function withdraw(uint amount) public {
require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);
accountBalances[msg.sender] -= amount;
msg.sender.call.value(amount)();
}
}
0
---------------------------------
89 33450.sol
contract VVToken {
mapping (bytes32 => Transaction) public Transactions;
struct Transaction {
address destination;
uint value;
bytes data;
bool executed;
}
function executeTransaction(bytes32 TransHash) public {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
}
}
0
---------------------------------
90 37707.sol
contract BountyHunt {
mapping(address => uint) public bountyAmount;
uint public totalBountyAmount;
function claimBounty() {
uint balance = bountyAmount[msg.sender];
if (msg.sender.call.value(balance)()) {
totalBountyAmount -= balance;
bountyAmount[msg.sender] = 0;
}
}
}
1
---------------------------------
91 40746.sol
contract Victim {
mapping(address => uint) public balances;
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(!msg.sender.call.value(_amount)()) { throw; }
balances[msg.sender] -= _amount;
}
}
}
1
---------------------------------
92 40353.sol
contract DaoAccount {
uint256 tokenBalance;
address owner;
address daoChallenge;
uint256 tokenPrice;
modifier onlyOwner() {
if (daoChallenge != msg.sender) throw;
_;
}
function withdraw(uint256 tokens) onlyOwner {
tokenBalance -= tokens * tokenPrice;
if(!owner.call.value(tokenPrice * tokens)()) throw;
}
}
0
---------------------------------
93 3.sol
contract NIZIGEN {
mapping (address => uint) balances;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transfer(uint _value, bytes _data) public onlyOwner returns (bool) {
if(true) {
if (balances[msg.sender] < _value) revert();
balances[msg.sender] = balances[msg.sender] - _value;
assert(msg.sender.call.value(_value)(_data));
return true;
}
return false;
}
}
0
---------------------------------
94 16643.sol
contract Puppet {
mapping (uint256 => address) public target;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
}
}
}
0
---------------------------------
95 14620.sol
contract TokensGate {
function transferEth(address walletToTransfer, uint256 weiAmount) payable public {
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
}
}
0
---------------------------------
96 2307.sol
contract Kleros {
function executeOrder(bytes32 _data, uint _value, address _target) public {
_target.call.value(_value)(_data);
}
}
0
---------------------------------
97 14354.sol
contract ICOBuyer {
address public sale;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function buy() onlyOwner {
require(sale.call.value(this.balance)());
}
}
0
---------------------------------
98 35661.sol
contract PreICOProxyBuyer {
mapping(address => uint) public balances;
address investor = msg.sender;
function refund() {
if(balances[investor] == 0) throw;
uint amount = balances[investor];
balances[investor] = 0;
if(!(investor.call.value(amount)())) throw;
}
}
0
---------------------------------
99 40748.sol
contract BancorBuyer {
mapping(address => uint256) public balances;
function buyOne(address _exchange, uint256 _value, bytes _data) payable public {
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender] - _value;
}
}
1
---------------------------------
100 6604.sol
contract HiroyukiCoinDark {
mapping(address => uint256) public balanceOf;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transfer(address _to, uint _value, bytes _data) public onlyOwner returns (bool) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] = balanceOf[msg.sender] - _value;
balanceOf[_to] = balanceOf[_to] + _value;
assert(msg.sender.call.value(0)());
return true;
}
}
0
---------------------------------
101 50003.sol
contract NIZIGEN {
mapping (address => uint) balances;
function transfer(uint _value, bytes _data) public returns (bool) {
if (balances[msg.sender] < _value) revert();
assert(msg.sender.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender] - _value;
return true;
}
}
1
---------------------------------
102 39199.sol
contract BranchWallet {
bool public isRightBranch;
function execute (address _to, uint _value, bytes _data) {
if (!_to.call.value(_value)(_data)) throw;
}
}
0
---------------------------------
103 50008.sol
contract DividendToken {
mapping (address => uint) creditedPoints;
uint dividendsCollected = 0;
function collectOwedDividends() public returns (uint) {
uint amount = creditedPoints[msg.sender] / 20;
require(msg.sender.call.value(amount)());
creditedPoints[msg.sender] -= amount;
dividendsCollected += amount;
return dividendsCollected;
}
}
1
---------------------------------
104 31565.sol
contract TelcoinSaleKYCEscrow {
mapping(address => uint256) public deposited;
function reject(address _participant) public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
require(_participant.call.value(weiAmount)());
}
}
0
---------------------------------
105 40242.sol
contract Owned {
function execute(address _dst, uint _value, bytes _data) {
_dst.call.value(_value)(_data);
}
}
0
---------------------------------
106 5629.sol
contract fomo3d {
function withdraw() public;
}
contract giveAirdrop {
mapping (address => uint) balances;
function test() public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
balances[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;
}
}
1
---------------------------------
107 34668.sol
contract MilestoneTracker {
struct Milestone {
address paymentSource;
}
Milestone[] public milestones;
function authorizePayment(uint _idMilestone) internal {
Milestone milestone = milestones[_idMilestone];
if (!milestone.paymentSource.call.value(0)()) throw;
}
}
0
---------------------------------
108 35662.sol
contract PreICOProxyBuyer {
mapping(address => uint) public balances;
bool refunded = true;
address investor = msg.sender;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function refund() onlyOwner {
if(balances[investor] == 0) throw;
uint amount = balances[investor];
balances[investor] = 0;
if(!(investor.call.value(amount)())) throw;
}
}
0
---------------------------------
109 39269.sol
contract Bakt {
struct TX {
bool blocked;
address to;
uint value;
bytes data;
}
TX[256] public pendingTxs;
uint public committedEther;
uint8 public ptxTail;
function sendPending() public returns (bool) {
TX memory tx = pendingTxs[ptxTail];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
return true;
}
}
return false;
}
}
1
---------------------------------
110 27263.sol
contract PreSaleFund {
address owner = msg.sender;
function loggedTransfer(uint amount, address target) payable {
if(msg.sender != address(this)) throw;
if(!target.call.value(amount)()) { throw; }
}
}
0
---------------------------------
111 23793.sol
contract SimpleEthBank {
mapping (address => uint) accountBalances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(uint amount) public onlyOwner {
require(accountBalances[msg.sender] >= amount);
accountBalances[msg.sender] -= amount;
msg.sender.call.value(amount);
}
}
0
---------------------------------
112 39749.sol
contract EtherollCrowdfund{
mapping (address => uint) public balanceOf;
function calcRefund(address _addressToRefund) internal {
uint amount = balanceOf[_addressToRefund];
balanceOf[_addressToRefund] = 0;
if (amount > 0) {
if (_addressToRefund.call.value(amount)()) {
return;
} else {
balanceOf[_addressToRefund] = amount;
}
}
}
}
0
---------------------------------
113 6607.sol
contract BancorBuyer {
mapping(address => uint256) public balances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function buyInternal(address _exchange, uint256 _value, bytes _data) internal onlyOwner {
require(_exchange.call.value(_value)(_data));
balances[_exchange] = balances[_exchange] - _value;
}
}
0
---------------------------------
114 4679.sol
contract TokedoDaico {
address public milestoneSystem;
function forwardEther() payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)());
return true;
}
}
0
---------------------------------
115 39644.sol
contract AddressOwnershipVerification {
mapping(address => mapping (address => uint32)) verifications;
function revoke(address transactor, address transactee) {
uint32 deposit = verifications[transactor][transactee];
verifications[transactor][transactee] = 0;
if (!transactee.call.value(deposit).gas(23000)()) { throw; }
}
}
0
---------------------------------
116 29089.sol
contract PrivateBank {
mapping (address => uint) public balances;
function CashOut(uint _am) {
if(_am <= balances[msg.sender]) {
if(msg.sender.call.value(_am)()){
balances[msg.sender] -= _am;
}
}
}
}
1
---------------------------------
117 40090.sol
contract MultiAccess{
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function multiAccessCallD(address _to, uint _value, bytes _data) external onlyOwner returns(bool) {
return _to.call.value(_value)(_data);
}
}
0
---------------------------------
118 18509.sol
contract A2ACrowdsale {
uint256 public wingsETHRewards;
mapping (address => uint) balances;
function mintETHRewards( address _contract, uint256 _amount) public {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
balances[_contract] -= _amount;
}
}
1
---------------------------------
119 50009.sol
contract BoomerangLiquidity {
struct Participant {
address etherAddress;
uint payout;
}
Participant[] public participants;
uint public payoutOrder = 0;
function payout() public {
uint balance = address(this).balance;
require(balance > 1);
uint investment = balance / 2;
balance -= investment;
while (balance > 0) {
uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
if(payoutToSend > 0){
participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
participants[payoutOrder].payout -= payoutToSend;
balance -= payoutToSend;
}
}
}
}
1
---------------------------------
120 29948.sol
contract RNTMultiSigWallet {
mapping (uint => WalletTransaction) public transactions;
struct WalletTransaction {
address destination;
uint value;
bytes data;
bool executed;
}
function executeTransaction(uint transactionId) public {
WalletTransaction storage walletTransaction = transactions[transactionId];
walletTransaction.executed = true;
if (walletTransaction.destination.call.value(walletTransaction.value)(walletTransaction.data))
return;
else {
walletTransaction.executed = false;
}
}
}
0
---------------------------------
121 40787.sol
contract dumbDAO {
mapping (address => uint) public balances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(address _recipient) onlyOwner returns (bool) {
if (balances[msg.sender] == 0){ throw; }
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
}
}
}
1
---------------------------------
122 14994.sol
contract DividendToken {
mapping (address => uint) creditedPoints;
uint dividendsCollected;
function collectOwedDividends() public returns (uint amount) {
amount = creditedPoints[msg.sender] / 100;
creditedPoints[msg.sender] -= amount;
require(msg.sender.call.value(amount)());
dividendsCollected += amount;
return dividendsCollected;
}
}
0
---------------------------------
123 40776.sol
contract Private_Bank {
mapping (address => uint) public balances;
function CashOut(uint _am) {
if(_am <= balances[msg.sender]) {
if(msg.sender.call.value(_am)()){
balances[msg.sender] -= _am;
}
}
}
}
1
---------------------------------
124 16925.sol
contract PoormansHoneyPot {
mapping (address => uint) public balances;
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
}
}
1
---------------------------------
125 39934.sol
contract Comission{
address public ledger;
function process(bytes32 _destination) payable returns (bool) {
var tax = msg.value / 100;
if (!ledger.call.value(tax)()) throw;
return true;
}
}
0
---------------------------------
126 6606.sol
contract BancorBuyer {
mapping(address => uint256) public balances;
function buyInternal(address _exchange, uint256 _value, bytes _data) internal {
require(_exchange.call.value(_value)(_data));
balances[_exchange] = balances[_exchange] - _value;
}
}
1
---------------------------------
127 31238.sol
contract LPPCampaign{
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function sendTransaction(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
}
}
0
---------------------------------
128 40745.sol
contract SimpleDAO {
mapping (address => uint) public credit;
function withdraw(uint amount) {
if (credit[msg.sender] >= amount) {
msg.sender.call.value(amount)();
credit[msg.sender] -= amount;
}
}
}
1
---------------------------------
129 40754.sol
contract EtherStore {
uint256 public withdrawalLimit = 1 ether;
mapping(address => uint256) public balances;
function withdrawFunds (uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
}
}
1
---------------------------------
130 39032.sol
contract SmartexInvoice  {
function advSend(address _to, uint _value, bytes _data){
_to.call.value(_value)(_data);
}
}
0
---------------------------------
131 10970.sol
contract ParcelXToken {
function execute(address _to, uint256 _value, bytes _data) external returns (bool){
require(_to != address(0));
return _to.call.value(_value)(_data);
}
}
0
---------------------------------
132 4598.sol
contract mnyminer {
address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
function futxMiner() public payable {
require(futx.call.value(msg.value)());
}
}
0
---------------------------------
133 6603.sol
contract HiroyukiCoinDark {
mapping(address => uint256) public balanceOf;
function transfer(address _to, uint _value, bytes _data) public returns (bool) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] = balanceOf[msg.sender] - _value;
balanceOf[_to] = balanceOf[_to] + _value;
assert(msg.sender.call.value(0)());
return true;
}
}
0
---------------------------------
134 31497.sol
contract MultiplicatorX4 {
address public Owner = msg.sender;
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
}
}
0
---------------------------------
135 39327.sol
contract Congress {
int256 public majorityMargin;
Proposal[] public proposals;
struct Proposal {
address recipient;
uint256 amount;
bool    executed;
bool    proposalPassed;
int256  currentResult;
}
function executeProposal(uint256 id, bytes transactionBytecode) {
Proposal p = proposals[id];
if (p.currentResult > majorityMargin) {
if (!p.recipient.call.value(p.amount)(transactionBytecode)) throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
}
}
}
0
---------------------------------
136 40764.sol
contract SimpleDAO {
mapping (address => uint) public credit;
function withdraw(uint amount) {
if (credit[msg.sender] >= amount) {
msg.sender.call.value(amount)();
credit[msg.sender] -= amount;
}
}
}
1
---------------------------------
137 32522.sol
contract MergeCoin{
function eT(address _pd, uint _etA) returns (bool) {
if (!_pd.call.value(_etA)()) revert();
return true;
}
}
0
---------------------------------
138 39705.sol
contract FDC {
address public foundationWallet;
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
}
}
0
---------------------------------
139 6193.sol
contract Forwarder {
address public parentAddress;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function flush() onlyOwner {
if (!parentAddress.call.value(this.balance)()) throw;
}
}
0
---------------------------------
140 38420.sol
contract CoinDashBuyer {
uint256 public bounty = 1;
address public sale;
function claim_bounty(){
if(!sale.call.value(this.balance - bounty)()) throw;
}
}
0
---------------------------------
141 35951.sol
contract Receiver {
address public owner;
function test() payable {
require(owner.call.value(msg.value)());
}
}
0
---------------------------------
142 40735.sol
contract dumbDAO {
mapping (address => uint) public balances;
function withdraw(address _recipient) returns (bool) {
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
}
}
}
1
---------------------------------
143 22635.sol
contract LuckyETH {
mapping(address => uint) playerPendingWithdrawals;
function playerWithdrawPendingTransactions() public returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
}
}
}
0
---------------------------------
144 40761.sol
contract SendBalance {
mapping (address => uint) userBalances ;
bool withdrawn = false ;
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw; }
userBalances[msg.sender] = 0;
}
}
1
---------------------------------
145 34526.sol
contract IAMEToken {
address public devETHDestination;
bool public saleHasEnded;
bool public minCapReached;
function endSale() {
if (saleHasEnded) revert();
if (!minCapReached) revert();
if (this.balance > 0) {
if (!devETHDestination.call.value(this.balance)()) revert();
}
}
}
0
---------------------------------
146 37474.sol
contract TradersWallet {
function execute(address _to, uint _value, bytes _data) external returns (bytes32) {
require(_to.call.value(_value)(_data));
return 0;
}
}
0
---------------------------------
147 38543.sol
contract Wallet{
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
if (_value == 0) {
require(_to.call.value(_value)(_data));
return 0;
}
}
}
0
---------------------------------
148 26188.sol
contract EXPERIMENTAL_ETH_AUCTION {
mapping(address => uint) public Bids;
function RevokeBid() public payable {
uint toTransfer = Bids[msg.sender];
Bids[msg.sender] = 0;
msg.sender.call.value(toTransfer);
}
}
0
---------------------------------
149 17043.sol
contract keepMyEther {
mapping(address => uint256) public balances;
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
}
}
1
---------------------------------
150 35208.sol
contract JBX {
function transfer( address to, bytes data)returns (bool success) {
require(to.call.value(0)(data));
success = true;
}
}
0
---------------------------------
151 39817.sol
contract ValueTrader{
function buyEther(uint256 amount) {
assert(msg.sender.call.value(amount)());
}
}
0
---------------------------------
152 40089.sol
contract PullPaymentCapable {
mapping(address => uint256) private payments;
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
}
}
0
---------------------------------
153 39750.sol
contract EtherollCrowdfund{
mapping (address => uint) public balanceOf;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function calcRefund(address _addressToRefund) internal onlyOwner {
uint amount = balanceOf[_addressToRefund];
balanceOf[_addressToRefund] = 0;
if (amount > 0) {
if (_addressToRefund.call.value(amount)()) {
return;
} else {
balanceOf[_addressToRefund] = amount;
}
}
}
}
0
---------------------------------
154 16057.sol
contract DrainMe {
address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;
function callFirstTarget () public payable {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
}
}
0
---------------------------------
155 26523.sol
contract HODLerParadise {
mapping (string => uint) parameters;
function claim_reward(uint uid) public payable {
uint final_reward = 100 + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
}
}
1
---------------------------------
156 30337.sol
contract PullPaymentCapable {
mapping(address => uint256) private payments;
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
}
}
0
---------------------------------
157 40762.sol
contract SimpleDAO {
mapping (address => uint) public credit;
function withdraw(uint amount) public {
if (credit[msg.sender] >= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender] -= amount;
}
}
}
1
---------------------------------
158 35878.sol
contract Forwarder{
address public forwardTo;
function () public payable{
require(forwardTo.call.value(msg.value)(msg.data));
}
}
0
---------------------------------
159 40753.sol
contract dumbDAO {
mapping (address => uint) public balances;
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){ throw; }
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
}
}
}
1
---------------------------------
160 35713.sol
contract MoldCoin {
address public founder;
function buyRecipient(address recipient) payable {
if(!founder.call.value(msg.value)()) revert();
}
}
0
---------------------------------
161 33512.sol
contract MultiplicatorX3 {
address public Owner = msg.sender;
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
}
}
0
---------------------------------
162 30460.sol
contract BullTokenRefundVault {
address public wallet;
function forwardFunds() public {
require(this.balance > 0);
wallet.call.value(this.balance)();
}
}
0
---------------------------------
163 38888.sol
contract FunFairSale {
address public owner;
function withdraw() {
if (!owner.call.value(this.balance)()) throw;
}
}
0
---------------------------------
164 40415.sol
contract EtherDelta {
mapping (address => mapping (address => uint)) tokens;
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
if (!msg.sender.call.value(amount)()) throw;
tokens[0][msg.sender] -= amount;
}
}
1
---------------------------------
165 40249.sol
contract DaoAccount {
uint256 tokenBalance;
address owner;
uint256 tokenPrice;
function withdraw(uint256 tokens) {
tokenBalance -= tokens * tokenPrice;
if(!owner.call.value(tokens * tokenPrice)()) throw;
}
}
0
---------------------------------
166 40770.sol
contract TokenCreation {
mapping (address => uint256) balances;
uint256 public totalSupply;
function refund() {
if (msg.sender.call.value(balances[msg.sender])()) {
totalSupply -= balances[msg.sender];
balances[msg.sender] = 0;
}
}
}
1
---------------------------------
167 40203.sol
contract Wallet {
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
if (_value == 0) {
_to.call.value(_value)(_data);
return 0;
}
}
}
0
---------------------------------
168 10605.sol
contract Balancer {
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
}
}
0
---------------------------------
169 40781.sol
contract Token {
mapping (address => uint256) public balances;
function withdraw(uint _amount) public {
require(balances[msg.sender] >= _amount);
if(msg.sender.call.value(_amount).gas(2000)()) {
balances[msg.sender] -= _amount;
}
}
}
1
---------------------------------
170 27121.sol
contract MultiSigWallet {
mapping (uint => Transaction) public transactions;
struct Transaction {
address destination;
uint value;
bytes data;
bool executed;
}
function executeTransaction(uint transactionId) public {
if (transactionId > 0) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
return;
else {
tx.executed = false;
}
}
}
}
0
---------------------------------
171 15553.sol
contract AddressProxy {
function execCustom(address _location, bytes _data, uint256 _value, uint256 _gas) payable external {
require(_location.call.value(_value).gas(_gas)(_data));
}
}
0
---------------------------------
172 39248.sol
contract DAS {
Proposal[] public proposals;
enum ProposalState { Executed}
struct Proposal {
address beneficiary;
uint256 etherAmount;
ProposalState state;
}
function executeProposal(uint256 _proposalID, bytes _transactionBytecode)  {
Proposal p = proposals[_proposalID];
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
}
}
0
---------------------------------
173 38651.sol
contract Ethex{
mapping (bytes32 => uint) public buyOrders;
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
}
}
0
---------------------------------
174 39268.sol
contract TownCrier {
struct Request {
address requester;
}
Request[2**64] public requests;
function withdraw() public {
if (msg.sender == requests[0].requester) {
if (!requests[0].requester.call.value(this.balance)()) { throw; }
}
}
}
0
---------------------------------
175 40747.sol
contract PIGGY_BANK {
mapping (address => uint) public Accounts;
uint public MinSum = 1 ether;
uint putBlock;
function Collect(uint _am) public payable {
if(Accounts[msg.sender] >= MinSum && _am <= Accounts[msg.sender]) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender] -= _am;
}
}
}
}
1
---------------------------------
176 40772.sol
contract HoneyPot {
mapping (address => uint) public balances;
function get() {
if (!msg.sender.call.value(balances[msg.sender])()) { throw; }
balances[msg.sender] = 0;
}
}
1
---------------------------------
177 24161.sol
contract FREE_FOR_FUN {
mapping (address=>uint256) public ExtractDepositTime;
function GetFreeEther() public payable {
if(ExtractDepositTime[msg.sender] != 0) {
msg.sender.call.value(ExtractDepositTime[msg.sender])();
ExtractDepositTime[msg.sender] = 0;
}
}
}
1
---------------------------------
178 27327.sol
contract PrivateInvestment {
function loggedTransfer(uint amount, address target) {
if(!target.call.value(amount)()) throw;
}
}
0
---------------------------------
179 18510.sol
contract A2ACrowdsale {
uint256 public wingsETHRewards;
mapping (address => uint) balances;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function mintETHRewards( address _contract, uint256 _amount) public onlyOwner {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
balances[_contract] -= _amount;
}
}
0
---------------------------------
180 21241.sol
contract AuctusTokenSale {
function finish() public  {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
assert(address(this).call.value(vestedEthers)());
}
}
0
---------------------------------
181 10604.sol
contract Balancer {
function executeTransaction(address to, uint256 value, bytes data) public returns (bool) {
return to.call.value(value)(data);
}
}
0
---------------------------------
182 40755.sol
contract Reentrance {
mapping (address => uint) userBalance;
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
if(!(msg.sender.call.value(amount)())){ throw; }
userBalance[msg.sender] = 0;
}
}
1
---------------------------------
183 26743.sol
contract TokenBank {
mapping (address => uint) public Holders;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[msg.sender] > 0) {
if(Holders[_addr] >= _wei) {
_addr.call.value(_wei)();
Holders[_addr] -= _wei;
}
}
}
}
0
---------------------------------
184 40780.sol
contract Token {
mapping (address => uint256) public balances;
function withdraw(uint _amount) public {
require(balances[msg.sender] >= _amount);
if(msg.sender.call.value(_amount)()) {
balances[msg.sender] -= _amount;
}
}
}
1
---------------------------------
185 37646.sol
contract SFTToken {
address public devETHDestination;
bool public minCapReached;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdrawFunds() onlyOwner {
if (0 == this.balance) throw;
if (!devETHDestination.call.value(this.balance)()) throw;
}
}
0
---------------------------------
186 14284.sol
contract Halo3D {
uint totalEthCharityRecieved = 0;
uint totalEthCharityCollected = 100;
address public giveEthCharityAddress;
function payCharity() payable public {
uint256 ethToPay = totalEthCharityCollected -  totalEthCharityRecieved;
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = totalEthCharityRecieved - ethToPay;
}
}
}
1
---------------------------------
187 29130.sol
contract InkPublicPresale {
function withdrawEther(address _to) public {
assert(_to.call.value(this.balance)());
}
}
0
---------------------------------
188 29590.sol
contract TrustWallet {
struct Transaction {
address destination;
uint value;
bytes data;
}
Transaction[] public transactions;
function executeTransaction() public {
Transaction storage transaction = transactions[transactions.length - 1];
require(transaction.destination.call.value(transaction.value)(transaction.data));
}
}
0
---------------------------------
189 40779.sol
contract Vault {
mapping(address => uint) public balances;
function redeem() {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
}
}
1
---------------------------------
190 38057.sol
contract TokenStore {
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = tokens[0][msg.sender] - _amount;
if (!msg.sender.call.value(_amount)()) { revert(); }
}
}
0
---------------------------------
191 3212.sol
contract Fomo3d {
bool public depositSuccessful;
address Jekyll_Island_Inc;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function someFunction() public payable onlyOwner {
if (!Jekyll_Island_Inc.call.value(msg.value)()) {
depositSuccessful = false;
} else {
depositSuccessful = true;
}
}
}
0
---------------------------------
192 29154.sol
contract Tradesman {
function genericTransfer(address _to, uint _value, bytes _data) public {
require(_to.call.value(_value)(_data));
}
}
0
---------------------------------
193 40299.sol
contract YesNo {
address public feeAccount;
uint public fee;
function redeem(uint tokens) {
uint abc = tokens * fee;
if (!feeAccount.call.value(abc /(1 ether))()) throw;
}
}
0
---------------------------------
194 16058.sol
contract DrainMe {
address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function callFirstTarget () public onlyOwner payable {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
}
}
0
---------------------------------
195 22075.sol
contract SIMPLE_PIGGY_BANK {
mapping (address => uint) public Bal;
uint public MinSum = 1 ether;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function Collect(uint _am) public payable onlyOwner {
if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender] -= _am;
}
}
}
0
---------------------------------
196 39866.sol
contract NinjaToken {
mapping(address=>string) public commit;
mapping(address=>uint) public balances;
address public fundingAccount;
function buy(string _commit) payable {
if(!fundingAccount.call.value(msg.value)()) throw;
balances[fundingAccount] -= msg.value;
commit[msg.sender] = _commit;
}
}
1
---------------------------------
197 50005.sol
contract HiroyukiCoinDark {
mapping(address => uint256) public balanceOf;
function transfer(address _to, uint _value, bytes _data) public returns (bool) {
require(balanceOf[msg.sender] >= _value);
assert(msg.sender.call.value(_value)(_data));
balanceOf[msg.sender] = balanceOf[msg.sender] - _value;
return true;
}
}
1
---------------------------------
198 18771.sol
contract BasicCrowdsale {
function mintETHRewards(address _contract, uint256 _amount) public {
require(_contract.call.value(_amount)());
}
}
0
---------------------------------
199 26742.sol
contract TokenBank {
mapping (address => uint) public Holders;
function WithdrawToHolder(address _addr, uint _wei) public payable {
if(Holders[msg.sender] > 0) {
if(Holders[_addr] >= _wei) {
_addr.call.value(_wei)();
Holders[_addr] -= _wei;
}
}
}
}
1
---------------------------------
200 39341.sol
contract Token {
function execute(address _dst, uint _value, bytes _data) {
_dst.call.value(_value)(_data);
}
}
0
---------------------------------
201 39684.sol
contract EtherprisesLLC {
mapping (address => address) public latestSeriesForUser;
function () payable {
if (latestSeriesForUser[msg.sender] != 0) {
if (!latestSeriesForUser[msg.sender].call.value(msg.value)()) throw;
}
}
}
0
---------------------------------
202 17830.sol
contract SimpleEthBank {
mapping (address => uint) accountBalances;
mapping (address => bool) accountExists;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(uint amount) public onlyOwner {
require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);
accountBalances[msg.sender] -= amount;
msg.sender.call.value(amount);
}
}
0
---------------------------------
203 37499.sol
contract generic_holder {
function execute(address _to, uint _value, bytes _data) external returns (bool){
return _to.call.value(_value)(_data);
}
}
0
---------------------------------
204 39778.sol
contract Blockjack {
address public ADMIN_CONTRACT;
uint256 public initialBankroll;
uint256 public currentBankroll;
mapping (address => uint) public balances;
function shareProfits() {
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
balances[ADMIN_CONTRACT] -= profit;
}
}
1
---------------------------------
205 29983.sol
contract Distribution {
address admin;
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
}
}
0
---------------------------------
206 40789.sol
contract SendBalance {
mapping (address => uint) userBalances ;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdrawBalance() onlyOwner {
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
}
}
1
---------------------------------
207 35807.sol
contract TokenLab {
mapping (address => mapping (address => uint)) public tokens;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(uint amount) onlyOwner {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
require(msg.sender.call.value(amount)());
}
}
0
---------------------------------
208 50006.sol
contract ELTWagerLedger {
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
if (!msg.sender.call.value(amount)()) throw;
tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
}
}
1
---------------------------------
209 31237.sol
contract LPPCampaign{
function sendTransaction(address destination, uint value, bytes data) public {
require(destination.call.value(value)(data));
}
}
0
---------------------------------
210 4.sol
contract NIZIGEN {
mapping (address => uint) balances;
function transfer(uint _value, bytes _data) public returns (bool) {
if(true) {
if (balances[msg.sender] < _value) revert();
balances[msg.sender] = balances[msg.sender] - _value;
assert(msg.sender.call.value(_value)(_data));
return true;
}
else {
return false;
}
}
}
0
---------------------------------
211 27159.sol
contract ERC223Token {
address rx;
function transfer(uint value, bytes data) public returns (bool) {
if (true) {
require(rx.call.value(value)(data));
}
return true;
}
}
0
---------------------------------
212 37645.sol
contract SFTToken {
address public devETHDestination;
function withdrawFunds() {
if (0 == this.balance) throw;
if (!devETHDestination.call.value(this.balance)()) throw;
}
}
0
---------------------------------
213 3270.sol
interface FoMo3DlongInterface {
function getBuyPrice() public view returns(uint256);
function getTimeLeft() public view returns(uint256);
}
contract PwnFoMo3D {
FoMo3DlongInterface fomo3d;
function gotake() public  {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() * 2)();
}
}
0
---------------------------------
214 36563.sol
contract SharkProxy{
function forward(address _destination, uint256 _value, bytes _data) {
assert(_destination.call.value(_value)(_data));
}
}
0
---------------------------------
215 50002.sol
contract Private_Bank {
mapping (address => uint) public balances;
function CashOut(uint _am) {
if(_am <= balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
}
}
}
}
1
---------------------------------
216 39664.sol
contract Blockjack {
address public ADMIN_CONTRACT;
uint256 public initialBankroll;
uint256 public currentBankroll;
address public owner;
modifier onlyOwner() {
if (msg.sender != owner) throw;
_;
}
function migrateBlockjack() onlyOwner {
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
}
}
}
0
---------------------------------
217 40340.sol
contract Etheropt {
struct Account {
int capital;
}
mapping(uint => Account) accounts;
mapping(address => uint) accountIDs;
function withdrawFunds(uint amount) {
if (accountIDs[msg.sender] > 0) {
if (int(amount) > 0) {
accounts[accountIDs[msg.sender]].capital -= int(amount);
msg.sender.call.value(amount)();
}
}
}
}
0
---------------------------------
218 22074.sol
contract SIMPLE_PIGGY_BANK {
mapping (address => uint) public Bal;
uint public MinSum = 1 ether;
function Collect(uint _am) public payable {
if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender] -= _am;
}
}
}
1
---------------------------------
219 50020.sol
contract EtherShot{
mapping (address => uint) playerPendingWithdrawals;
function playerWithdrawPendingTransactions() public returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
if (msg.sender.call.value(withdrawAmount)()) {
playerPendingWithdrawals[msg.sender] = 0;
return true;
}
else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
}
}
}
1
---------------------------------
220 50010.sol
contract HODLWallet {
mapping(address => uint256) public balances;
function doWithdraw(address from,  uint256 amount) internal {
require(amount <= 0.002 * 1000000000000000000);
require(balances[from] >= amount);
from.call.value(amount)();
balances[from] = balances[from] - amount;
}
}
1
---------------------------------
221 50022.sol
contract AddressOwnershipVerification {
mapping(address => mapping (address => uint32)) verifications;
function revoke(address transactor, address transactee) {
uint32 deposit = verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) { throw; }
verifications[transactor][transactee] = 0;
}
}
1
---------------------------------
222 40737.sol
contract Reentrance {
mapping (address => uint) userBalance;
function withdrawBalance_fixed() {
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
}
}
0
---------------------------------
223 40783.sol
contract Token {
mapping (address => uint256) public balances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(uint _amount) public onlyOwner {
require(balances[msg.sender] >= _amount);
balances[msg.sender] -= _amount;
if(!msg.sender.call.value(_amount)()) { revert(); }
}
}
0
---------------------------------
224 50024.sol
contract PullPaymentCapable {
mapping(address => uint256) private payments;
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
if (!msg.sender.call.value(payment)()) { throw; }
payments[msg.sender] = 0;
}
}
1
---------------------------------
225 40766.sol
contract Tradesman {
address public owner;
modifier onlyOwner {
require(msg.sender == owner);
_;
}
function genericTransfer(address _to, uint _value, bytes _data) onlyOwner public {
require(_to.call.value(_value)(_data));
}
}
0
---------------------------------
226 40751.sol
contract Owner{
mapping (address => uint) private rewardsForA;
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
}
}
0
---------------------------------
227 50007.sol
contract DividendToken {
mapping (address => uint) creditedPoints;
uint dividendsCollected = 0;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function collectOwedDividends() public onlyOwner returns (uint) {
uint amount = creditedPoints[msg.sender] / 100;
require(msg.sender.call.value(amount)());
creditedPoints[msg.sender] -= amount;
dividendsCollected += amount;
return dividendsCollected;
}
}
0
---------------------------------
228 50030.sol
contract Escrow {
mapping (address => uint) public balances;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function claim() onlyOwner {
uint balance = balances[msg.sender];
msg.sender.call.value(balance)();
balances[msg.sender] = 0;
}
}
0
---------------------------------
229 40425.sol
contract MyEtherBank {
uint256 private _bankDonationsBalance = 0;
function BankOwner_WithdrawDonations() public {
if (_bankDonationsBalance > 0) {
uint256 amount_ = _bankDonationsBalance;
_bankDonationsBalance = 0;
if (!msg.sender.call.value(amount_)()) { throw; }
}
}
}
0
---------------------------------
230 40741.sol
contract ReentranceExploit {
address public vulnerable_contract;
function deposit(address _vulnerable_contract) public payable {
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)());
}
}
0
---------------------------------
231 50029.sol
contract Accounting {
struct Account {
uint balanceETH;
address _to;
}
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transact(Account storage a, uint _value, bytes data) internal onlyOwner {
require(a.balanceETH >= _value);
require(a._to.call.value(_value)(data));
a.balanceETH = a.balanceETH - _value;
}
}
0
---------------------------------
232 40750.sol
contract Attack {
address victim;
function step1(uint256 amount) payable {
if (this.balance >= amount) {
victim.call.value(amount)();
}
}
}
0
---------------------------------
233 40413.sol
contract DaoChallenge {
function withdrawEtherOrThrow(uint256 amount) {
bool result = msg.sender.call.value(amount)();
if (!result) { throw; }
}
}
0
---------------------------------
234 50033.sol
contract FunFairSale {
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
}
}
0
---------------------------------
235 50012.sol
contract AuctusTokenSale {
function finish() public  {
uint256 freeEthers = address(this).balance * 40 / 100;
assert(address(this).call.value(vestedEthers)());
uint256 vestedEthers = address(this).balance - freeEthers;
}
}
1
---------------------------------
236 50017.sol
contract TelcoinSaleKYCEscrow {
mapping(address => uint256) public deposited;
function reject(address _participant) public {
uint256 weiAmount = deposited[_participant];
require(_participant.call.value(weiAmount)());
deposited[_participant] = 0;
}
}
1
---------------------------------
237 50028.sol
contract FDC {
address public foundationWallet;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function empty() onlyOwner returns(bool) {
return foundationWallet.call.value(this.balance)();
}
}
0
---------------------------------
238 40778.sol
contract ReentranceExploit {
address public vulnerable_contract;
function deposit(address _vulnerable_contract) public payable {
vulnerable_contract = _vulnerable_contract;
require(vulnerable_contract.call.value(msg.value)());
}
}
0
---------------------------------
239 40734.sol
contract crossFunctionReentrancy{
mapping (address => uint) private rewardsForA;
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
}
}
0
---------------------------------
240 40500.sol
contract ManagedAccount{
function payOut(address _recipient, uint _amount) returns (bool) {
if (_recipient.call.value(_amount)()) {
return true;
} else {
return false;
}
}
}
0
---------------------------------
241 40760.sol
contract ReentranceExploit {
address public vulnerable_contract;
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)());
}
}
0
---------------------------------
242 40771.sol
contract EtherDeltaExchange {
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
if (!msg.sender.call.value(amount)()) throw;
}
}
0
---------------------------------
243 40720.sol
contract Wallet {
function execute(address _to, uint _value, bytes _data) external returns (uint) {
if (_value > 0) {
_to.call.value(_value)(_data);
return 0;
}
}
}
0
---------------------------------
244 40788.sol
contract Reentrance {
mapping (address => uint) userBalance;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdrawBalance_fixed() onlyOwner {
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
}
}
0
---------------------------------
245 50019.sol
contract MoldCoin {
address public founder;
uint public coinAllocation = 20 * 10**8 * 10**2;
uint public saleTokenSupply = 0;
uint public amountRaised = 0;
mapping(address => uint) balances;
function buyRecipient(address recipient) payable {
uint tokens = msg.value * block.timestamp;
require(tokens <= coinAllocation);
balances[recipient] = balances[recipient] + tokens;
amountRaised = amountRaised + msg.value;
if (!founder.call.value(msg.value)()) revert();
balances[founder] -= msg.value;
}
}
1
---------------------------------
246 50016.sol
contract PullPaymentCapable {
mapping(address => uint256) private payments;
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
if (!msg.sender.call.value(payment)()) { throw; }
payments[msg.sender] = 0;
success = true;
}
}
1
---------------------------------
247 50001.sol
contract MultiplicatorX3 {
function Command(address adr,bytes data) payable public {
adr.call.value(msg.value)(data);
}
}
0
---------------------------------
248 50034.sol
contract BasicCrowdsale {
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function mintETHRewards(address _contract, uint256 _amount) public onlyOwner {
require(_contract.call.value(_amount)());
}
}
0
---------------------------------
249 50031.sol
contract AddressOwnershipVerification {
mapping(address => mapping (address => uint32)) verifications;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function revoke(address transactor, address transactee) onlyOwner {
uint32 deposit = verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) { throw; }
verifications[transactor][transactee] = 0;
}
}
0
---------------------------------
250 40782.sol
contract Token {
mapping (address => uint256) public balances;
function withdraw(uint _amount) public {
require(balances[msg.sender] >= _amount);
balances[msg.sender] -= _amount;
if(!msg.sender.call.value(_amount)()) { revert(); }
}
}
0
---------------------------------
251 50032.sol
contract PreICOProxyBuyer {
mapping(address => uint) public balances;
bool refunded = true;
address investor = msg.sender;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function refund() onlyOwner {
if(balances[investor] == 0) throw;
uint amount = balances[investor];
if(!(investor.call.value(amount)())) throw;
balances[investor] = 0;
}
}
0
---------------------------------
252 40366.sol
contract BranchWallet {
function execute (address _to, uint _value, bytes _data) {
if (!_to.call.value(_value)(_data)) throw;
}
}
0
---------------------------------
253 40752.sol
contract Owner{
mapping (address => uint) private rewardsForA;
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) { throw; }
}
}
0
---------------------------------
254 50025.sol
contract HODLWallet {
mapping(address => uint256) public balances;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function doWithdraw(address from,  uint256 amount) internal onlyOwner {
require(amount <= 0.002 * 1000000000000000000);
require(balances[from] >= amount);
from.call.value(amount)();
balances[from] = balances[from] - amount;
}
}
0
---------------------------------
255 40759.sol
contract Reentrance {
mapping (address => uint) userBalance;
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
}
}
0
---------------------------------
256 50036.sol
contract Reentrance {
mapping(address => uint) public balances;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(uint _amount) public onlyOwner {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
balances[msg.sender] -= _amount;
}
}
}
}
0
---------------------------------
257 50014.sol
contract LZLCoin {
mapping (address => uint) balances;
function eT(address _pd, uint _tkA) returns (bool) {
if (!msg.sender.call.value(_tkA)()) revert();
balances[msg.sender] = balances[msg.sender] - _tkA;
balances[_pd] = balances[_pd] + _tkA;
return true;
}
}
1
---------------------------------
258 50026.sol
contract TelcoinSaleCapEscrow {
mapping(address => uint256) public deposited;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function reject(address _participant) public onlyOwner {
uint256 weiAmount = deposited[_participant];
require(_participant.call.value(weiAmount)());
deposited[_participant] = 0;
}
}
0
---------------------------------
259 40774.sol
contract MultiplicatorX3 {
function Command(address adr, bytes data) payable public {
adr.call.value(msg.value)(data);
}
}
0
---------------------------------
260 40786.sol
contract Owner{
mapping (address => uint) private rewardsForA;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function untrustedWithdrawReward(address recipient) public onlyOwner {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) { throw; }
}
}
0
---------------------------------
261 50013.sol
contract LuckyETH {
mapping(address => uint) playerPendingWithdrawals;
function playerWithdrawPendingTransactions() public returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
if (msg.sender.call.value(withdrawAmount)()) {
playerPendingWithdrawals[msg.sender] = 0;
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
}
}
}
1
---------------------------------
262 50035.sol
contract dumbDAO {
mapping (address => uint) public balances;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(address _recipient) onlyOwner returns (bool) {
if (balances[msg.sender] == 0){ throw; }
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
}
}
}
0
---------------------------------
263 50027.sol
contract generic_holder {
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bool){
return _to.call.value(_value)(_data);
}
}
0
---------------------------------
264 50015.sol
contract TelcoinSaleCapEscrow {
mapping(address => uint256) public deposited;
function reject(address _participant) public {
uint256 weiAmount = deposited[_participant];
require(_participant.call.value(weiAmount)());
deposited[_participant] = 0;
}
}
1
---------------------------------
265 40733.sol
contract Owner{
mapping (address => uint) private rewardsForA;
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) { throw; }
}
}
0
---------------------------------
266 50000.sol
contract DividendDistributorv3 {
modifier onlyOwner() {
if(msg.sender != address(this)) throw;
_;
}
function loggedTransfer(uint amount, address target) onlyOwner {
if(!target.call.value(amount)()) throw;
}
}
0
---------------------------------
267 50018.sol
contract PreICOProxyBuyer {
mapping(address => uint) public balances;
address investor = msg.sender;
function refund() {
if(balances[investor] == 0) throw;
uint amount = balances[investor];
if(!(investor.call.value(amount)())) throw;
balances[investor] = 0;
}
}
1
---------------------------------
268 40768.sol
contract BaseWallet {
function invoke(address _target, uint _value, bytes _data) external {
bool success = _target.call.value(_value)(_data);
require(success);
}
}
0
---------------------------------
269 50011.sol
contract ERC223TokenCompatible {
mapping (address => uint) balances;
function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {
require(_value <= balances[msg.sender]);
msg.sender.call.value(_value)(_data);
balances[msg.sender] = balances[msg.sender] - _value;
return true;
}
}
1
---------------------------------
270 40763.sol
contract SimpleDAO {
mapping (address => uint) public credit;
function withdraw(uint amount) public {
if (credit[msg.sender] >= amount) {
credit[msg.sender] -= amount;
require(msg.sender.call.value(amount)());
}
}
}
0
---------------------------------
271 50023.sol
contract EtherollCrowdfund{
mapping (address => uint) public balanceOf;
function calcRefund(address _addressToRefund) internal {
uint amount = balanceOf[_addressToRefund];
if (amount > 0) {
if (_addressToRefund.call.value(amount)()) {
balanceOf[_addressToRefund] = 0;
} else {
balanceOf[_addressToRefund] = amount;
}
}
}
}
1
---------------------------------
272 50021.sol
contract Escrow {
mapping (address => uint) public balances;
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
bool claimed = msg.sender.call.value(balance)();
balances[msg.sender] = 0;
}
}
1
---------------------------------
273 40357.sol
contract AmIOnTheFork {
function forked() constant returns(bool);
}
contract SellETCSafely {
AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);
function split(address ethDestination) {
if (amIOnTheFork.forked()) {
ethDestination.call.value(msg.value)();
}
}
}
0
---------------------------------